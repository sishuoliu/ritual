# 以「功德轮回」半合作 RPG 桌游驱动引擎开发 — Pros & Cons

> 策略：一边以设计「功德轮回」为实例，一边开发桌游设计引擎（规则 DSL、模拟、回测、AI 反馈）。  
> 游戏定位：半合作 RPG 桌游（团队胜利 + 个人计分；劫难/渡化/发愿/角色/事件卡/众生卡）。

---

## Pros（好处）

### 1. 需求真实、边界清晰
- 规则已有 v0.3→v3.6 的完整迭代，**真实设计问题**（平衡、回合数、渡化门槛、劫难曲线）都出现过，引擎要解决的「改规则→跑局→看数据」是刚需。
- 胜利条件明确（团队：劫难≤12 且渡化≥6；个人：福慧+发愿），**指标好定义**（胜率、回合分布、资源曲线），回测和 AI 反馈都有抓手。

### 2. 复杂度适中，适合当「第一个完整用例」
- 有回合阶段、多角色、多资源、卡牌（事件/众生/发愿）、骰子判定，但**没有**超大型版图或海量卡池，足够覆盖引擎需要的核心抽象（阶段、行动、判定、卡牌堆、全局状态），又不至于第一版就做不动。
- 半合作（先团队后个人）能顺带验证引擎是否支持「多层胜负/计分」，为以后其他桌游扩展打样。

### 3. 历史资产可直接复用
- Archive 里已有**规则书、平衡报告、事件/众生表、发愿设计**，可直接当作「自然语言 + 表格」输入，用来驱动：  
  - 规则 DSL 的设计（先覆盖功德轮回用到的概念）；  
  - 回测指标的定义（劫难、渡化、福慧、回合数等）；  
  - AI 反馈的 prompt 示例（规则摘要 + 对局数据 → 平衡/体验建议）。
- 若有旧版 Python 模拟器逻辑，可**对照迁移**到引擎的「规则解释器 + 模拟循环」，避免从零造轮子。

### 4. 设计迭代与引擎迭代同频
- 每次你**改功德轮回的规则或数值**（例如渡化门槛、事件效果、发愿分），都自然变成对引擎的**真实测试**：解析是否通过、模拟是否合理、回测是否稳定、AI 反馈是否有用。
- 引擎设计决策（例如「阶段怎么表达」「卡牌效果怎么挂接」）会立刻在功德轮回上得到验证，减少过度抽象或脱离使用场景的设计。

### 5. 主题与已有工作一致
- 你已在该项目上投入大量设计文档与模拟经验，**继续用同一款游戏**做引擎的 driver，心智负担小，也便于把「设计直觉」沉淀成引擎的默认工作流和文档。

---

## Cons（风险与代价）

### 1. 引擎容易「功德轮回专用化」
- **风险**：为赶进度或图省事，把引擎的接口、数据结构、阶段/行动命名都绑死在功德轮回上（例如硬编码「事件阶段」「众生阶段」「渡化」），后续做第二款桌游时要大改。
- **缓解**：  
  - 从第一天起用**通用术语**命名引擎层概念（如 phase / action / resource / deck / global state），功德轮回只作为「一种规则配置」；  
  - 每加一个机制，问一句「另一款桌游会不会也需要？」若会，就做成可配置项而不是写死。

### 2. 设计需求可能倒逼引擎过早复杂化
- **风险**：功德轮回里若某次迭代加入「隐藏目标」「叛徒」「谈判」等，会倒逼引擎支持复杂状态与多人信息不对称；若引擎一开始就为这些设计，会拖延 MVP。
- **缓解**：  
  - 明确 **MVP 范围**：例如第一版只支持「完全信息、确定性可复现、无谈判」的模拟；隐藏目标/叛徒先用手工脚本或占位符，等引擎稳定后再抽象成通用机制。  
  - 在文档里写清「当前引擎支持 / 暂不支持」的机制清单，避免需求蔓延。

### 3. 时间在「做游戏」与「做引擎」之间分流
- **风险**：同时推进「功德轮回的下一版设计」和「引擎的下一版功能」，容易两边都做不深，或为赶游戏进度在引擎外写临时脚本，导致引擎被架空。
- **缓解**：  
  - **以引擎为主、游戏为用例**：优先保证「改规则 → 模拟 → 回测」这条链路在引擎内跑通；功德轮回的迭代尽量都通过改配置/DSL 完成，避免在引擎外再维护一套独立模拟器。  
  - 设定小里程碑（例如「用引擎跑通功德轮回 v3.6 一局」「用引擎跑 100 局并产出与旧脚本一致的汇总指标」），完成后再加新游戏机制或新引擎能力。

### 4. 半合作与多人策略的模拟难度
- **风险**：半合作下「最优策略」依赖对手行为与团队协调，纯随机或多智能体策略可能难以复现真人体验，回测结果可能和实局感受有偏差。
- **缓解**：  
  - 第一版接受「简单策略 + 随机」的模拟，重点验证**规则一致性、数值稳定性、回合/资源曲线**；  
  - 明确回测目标：是「发现明显不平衡/死局」和「对比规则版本差异」，而不是「预测真人胜率」。  
  - 后续再考虑接入简单 AI 或固定策略组合，作为可选模块。

### 5. 文档与示例容易混在一起
- **风险**：引擎文档里塞满功德轮回专有名词，或设计提案里塞满引擎 API，新读者/协作者难以分清「通用引擎」和「示例游戏」。
- **缓解**：  
  - **目录分离**：例如 `engine/`（引擎核心）、`games/merit-cycle/`（功德轮回配置与说明）、`docs/`（引擎设计文档 + 调研）；  
  - 引擎文档只引用「示例游戏」为 usage example，不把规则细节写进引擎 spec；功德轮回的规则书与设计迭代保留在设计提案/规则目录下。

---

## 总结建议

| 维度           | 建议 |
|----------------|------|
| **是否用功德轮回当 driver** | **推荐用**。需求真实、资产现成、复杂度适中，利大于弊。 |
| **抽象层级**   | 引擎层坚持**通用概念**（阶段、行动、资源、牌堆、胜负）；功德轮回只作为配置与示例。 |
| **优先级**     | 先让「功德轮回 v3.6 在引擎内可配置、可模拟、可回测」，再扩展新机制或第二款游戏。 |
| **风险控制**   | 用「支持/暂不支持」清单和 MVP 范围约束需求；避免在引擎外再维护一套独立模拟器。 |

整体上，**一边做功德轮回设计、一边做引擎，用这一款半合作 RPG 当唯一 driver，是可行且有利的**；只要刻意保持引擎的通用命名与边界，并把「引擎优先、游戏为用例」的执行顺序坚持住，cons 大多可以控制在可接受范围内。
